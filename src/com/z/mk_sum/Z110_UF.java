package com.z.mk_sum;

/*
Union Find, 并查集
    Quick Find
    Quick Union
    基于 size 的优化
    基于 rank 的优化
    路径压缩


问题
    连接问题
    路径问题


对于一组数据，主要支持两个动作:
    isConnected( p，q )
        是否处于同一个集合
    unionElem(p, q)
        将 p 所处集合中的所有元素 合并到 q 所处的集合
            前面的节点指向后面的根节点
        将 q 所处集合中的所有元素 合并到 p 所处的集合


并查集的基本数据表示
    0 1 2 3 4 5 6, 键: 元素
    0 0 0 0 1 1 1, 值: 集合

    isConnected(2, 3) == true
    isConnected(3, 4) == false

    unionElem(3, 4)
        0 1 2 3 4 5 6, 键: 元素
        1 1 1 1 1 1 1, 值: 集合


Quick Find
    int[] elems;
        索引为 元素
        值  为 集合

    isConnected
        O(1)
    unionElem
        O(n)
        此处需要遍历一遍数组元素，慢


Quick Union
    将每一个元素，看做是一个节点
    前面的节点指向后面的根节点

    int[] parent;
        索引为 元素
        值  为 集合

    isConnected
        O(h)
    unionElem
        O(h)
        找到元素的根节点，快
        问题: 多叉树 退化成 链表


基于 size 的优化
    让节点少的那棵树的根指向节点多的树的根节点
    这样可以尽可能避免树的高度增加

    int[] parent;
        索引为 元素
        值  为 集合
    int[] size;
        size[i]表示以i为根的集合中元素个数

        1           4
            2
                3
    --------------------- 合并方式一，两棵树的最大深度增加
                    4
                1
                    2
                        3
    --------------------- 合并方式二，两棵树的最大深度不变
        1
    4       2
                3

    --------------------- 问题, size 表示 横向 大小，而不是 纵向 大小
            7               8
    0   1   2   5   6       4
                            3

    --------------------- 合并方式一，两棵树的最大深度增加
            7
    0   1   2   5   6   8
                        4
                        3
    --------------------- 合并方式二，两棵树的最大深度不变(基于 rank 的优化)
                        8
            7           4
    0   1   2   5   6   3


基于 rank 的优化
    深度比较低的那棵树的根节点指向深度比较高的根节点

    int[] parent;
        索引为 元素
        值  为 集合
    int[] rank;
        rank[i]表示以i为根的集合所表示的树的层数

        8           16
            6           18
                            20
    深度没有发生改变
            16
         8      18
            6       20


路径压缩，Path Compression
    在 find 方法中进行优化
        1) parent[p] = parent[parent[p]];   // 循环，多层
        2) p = find(parent[p]);             // 递归，两层

                    0
                1
            2
        3
    4
    ------------------ find 4，查找 4 所处的集合(元素4的根节点)
                    0
                1
            2
        3       4
    ------------------
                    0
                1       2
                    3       4


并查集的时间复杂度分析
    复杂
 */
interface Z110_UF {
}
